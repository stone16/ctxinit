/**
 * Base compiler interface and abstract class for target-specific compilation
 */

import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { ParsedRule } from '../schemas/rule';
import { Config } from '../schemas/config';

/**
 * Compilation result
 */
export interface CompilationResult {
  /** Whether compilation succeeded */
  success: boolean;
  /** Output files generated */
  outputs: OutputFile[];
  /** Errors encountered */
  errors: CompilationError[];
  /** Warnings generated */
  warnings: CompilationWarning[];
  /** Total tokens in output */
  totalTokens: number;
  /** Compilation statistics */
  stats: CompilationStats;
}

/**
 * Output file generated by compilation
 */
export interface OutputFile {
  /** Output file path (relative to project root) */
  path: string;
  /** File content */
  content: string;
  /** Estimated tokens */
  tokens: number;
}

/**
 * Compilation error
 */
export interface CompilationError {
  /** Error type */
  type: 'missing_file' | 'write_error' | 'parse_error' | 'config_error';
  /** Error message */
  message: string;
  /** Related file path */
  path?: string;
}

/**
 * Compilation warning
 */
export interface CompilationWarning {
  /** Warning type */
  type: 'missing_optional' | 'truncated' | 'empty_rules' | 'token_limit';
  /** Warning message */
  message: string;
  /** Related file path */
  path?: string;
}

/**
 * Compilation statistics
 */
export interface CompilationStats {
  /** Number of rules processed */
  rulesProcessed: number;
  /** Number of rules included */
  rulesIncluded: number;
  /** Number of output files */
  outputFiles: number;
  /** Total tokens in output */
  totalTokens: number;
  /** Token budget (if applicable) */
  tokenBudget?: number;
}

/**
 * Compiler context with project information
 */
export interface CompilerContext {
  /** Project root directory */
  projectRoot: string;
  /** Configuration */
  config: Config;
  /** Parsed rules */
  rules: ParsedRule[];
  /**
   * Whether compilers should write outputs to disk.
   * When false, compilers only return `outputs` and the caller is responsible for writing.
   * (Default: true)
   */
  writeToDisk?: boolean;
  /** Project description content (from project.md) */
  projectContent?: string;
  /** Architecture content (from architecture.md) */
  architectureContent?: string;
}

/**
 * Abstract base compiler class
 */
export abstract class BaseCompiler {
  protected context: CompilerContext;

  constructor(context: CompilerContext) {
    this.context = context;
  }

  /**
   * Compile rules to target format
   */
  abstract compile(): Promise<CompilationResult>;

  /**
   * Get the target name (e.g., 'cursor', 'claude', 'agents')
   */
  abstract get targetName(): string;

  /**
   * Load project.md content
   */
  protected async loadProjectContent(): Promise<string | undefined> {
    const projectPath = path.join(this.context.projectRoot, '.context', 'project.md');
    try {
      return fs.readFileSync(projectPath, 'utf-8');
    } catch {
      return undefined;
    }
  }

  /**
   * Load architecture.md content
   */
  protected async loadArchitectureContent(): Promise<string | undefined> {
    const archPath = path.join(this.context.projectRoot, '.context', 'architecture.md');
    try {
      return fs.readFileSync(archPath, 'utf-8');
    } catch {
      return undefined;
    }
  }

  /**
   * Ensure output directory exists
   */
  protected ensureDirectory(dirPath: string): void {
    const fullPath = path.join(this.context.projectRoot, dirPath);
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
    }
  }

  /**
   * Write output file
   */
  protected writeOutput(filePath: string, content: string): void {
    const fullPath = path.join(this.context.projectRoot, filePath);
    const dirPath = path.dirname(fullPath);

    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    fs.writeFileSync(fullPath, content, 'utf-8');
  }

  /**
   * Generate Context Hygiene meta-rule content
   */
  protected generateMetaRule(): string {
    return `
## Context Hygiene

This context file was automatically generated by ctxinit.
- Do not edit this file directly; changes will be overwritten on next build.
- To modify rules, edit source files in \`.context/rules/\`.
- Run \`ctx build\` to regenerate this file.
- Run \`ctx verify\` to check for tampering.
`;
  }

  /**
   * Generate directory index for agent navigation
   */
  protected generateDirectoryIndex(rules: ParsedRule[]): string {
    const lines: string[] = ['## Rule Directory', ''];

    // Group rules by directory
    const byDir = new Map<string, ParsedRule[]>();
    for (const rule of rules) {
      const dir = path.dirname(rule.path) || '.';
      const existing = byDir.get(dir) || [];
      existing.push(rule);
      byDir.set(dir, existing);
    }

    // Sort directories
    const sortedDirs = Array.from(byDir.keys()).sort();

    for (const dir of sortedDirs) {
      const dirRules = byDir.get(dir)!;
      lines.push(`### ${dir === '.' ? 'Root' : dir}`);
      lines.push('');

      for (const rule of dirRules) {
        const desc = rule.frontmatter.description || 'No description';
        lines.push(`- **${rule.frontmatter.id}**: ${desc}`);
      }
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Get summary of rule (description + first paragraph)
   */
  protected getRuleSummary(rule: ParsedRule): string {
    const desc = rule.frontmatter.description || '';
    const firstParagraph = rule.content.split('\n\n')[0] || '';
    return [desc, firstParagraph].filter(Boolean).join('\n\n');
  }

  /**
   * Generate SHA-256 checksum for content
   */
  protected generateChecksum(content: string): string {
    // Normalize line endings so checksums are stable across environments (e.g., CRLF vs LF).
    const normalized = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    const hash = crypto.createHash('sha256').update(normalized).digest('hex');
    return `sha256:${hash}`;
  }

  /**
   * Generate build timestamp in ISO format
   */
  protected generateTimestamp(): string {
    return new Date().toISOString();
  }

  /**
   * Generate footer with checksum and timestamp
   * The checksum is calculated on the content BEFORE appending this footer
   */
  protected generateFooter(content: string): string {
    const checksum = this.generateChecksum(content);
    const timestamp = this.generateTimestamp();

    return `
<!-- ctx build metadata -->
<!-- timestamp: ${timestamp} -->
<!-- checksum: ${checksum} -->
`;
  }

  /**
   * Add checksum and timestamp footer to content
   */
  protected addMetadata(content: string): string {
    return content + this.generateFooter(content);
  }
}
