/**
 * Verify Command
 *
 * Checksum verification for compiled outputs:
 * - Verify CLAUDE.md, AGENTS.md, .mdc files haven't been tampered with
 * - Compare embedded checksums with actual file content
 */

import * as path from 'path';
import * as fs from 'fs';
import chalk from 'chalk';
import * as crypto from 'crypto';

/**
 * Verify command options
 */
export interface VerifyCommandOptions {
  /** Show detailed output */
  verbose?: boolean;
  /** Output in JSON format */
  json?: boolean;
}

/**
 * Verification result for a single file
 */
interface FileVerificationResult {
  path: string;
  exists: boolean;
  hasChecksum: boolean;
  embeddedChecksum?: string;
  actualChecksum?: string;
  valid: boolean;
  error?: string;
}

/**
 * Extract embedded checksum from file content
 * Looks for: <!-- checksum: sha256:HASH -->
 */
function extractChecksum(content: string): string | null {
  const match = content.match(/<!--\s*checksum:\s*(sha256:[a-f0-9]{64})\s*-->/i);
  return match ? match[1] : null;
}

/**
 * Calculate content checksum (excluding the entire footer block)
 *
 * The footer consists of 3 lines appended AFTER the checksum is calculated:
 *   <!-- ctx build metadata -->
 *   <!-- timestamp: ... -->
 *   <!-- checksum: sha256:... -->
 *
 * We must remove ALL of these to match the original checksum calculation.
 */
function calculateChecksum(content: string): string {
  // Remove the entire footer block (metadata comment + timestamp + checksum)
  // This matches what base-compiler.ts does: calculate checksum on content BEFORE footer
  const cleanContent = content.replace(
    /\n<!-- ctx build metadata -->\n<!-- timestamp: [^\n]+ -->\n<!-- checksum: sha256:[a-f0-9]{64} -->\s*$/,
    ''
  );
  const hash = crypto.createHash('sha256').update(cleanContent).digest('hex');
  return `sha256:${hash}`;
}

/**
 * Verify a single file
 */
async function verifyFile(filePath: string): Promise<FileVerificationResult> {
  const result: FileVerificationResult = {
    path: filePath,
    exists: false,
    hasChecksum: false,
    valid: false,
  };

  try {
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      result.error = 'File not found';
      return result;
    }
    result.exists = true;

    // Read content
    const content = await fs.promises.readFile(filePath, 'utf-8');

    // Extract embedded checksum
    const embeddedChecksum = extractChecksum(content);
    if (!embeddedChecksum) {
      result.error = 'No checksum found in file (file may not be generated by ctx)';
      return result;
    }
    result.hasChecksum = true;
    result.embeddedChecksum = embeddedChecksum;

    // Calculate actual checksum
    result.actualChecksum = calculateChecksum(content);

    // Compare
    result.valid = result.embeddedChecksum === result.actualChecksum;
    if (!result.valid) {
      result.error = 'Checksum mismatch - file has been modified';
    }

    return result;
  } catch (error) {
    result.error = (error as Error).message;
    return result;
  }
}

/**
 * Run the verify command
 */
export async function runVerify(options: VerifyCommandOptions): Promise<number> {
  const projectRoot = process.cwd();

  // Files to verify
  const filesToVerify = [
    path.join(projectRoot, 'CLAUDE.md'),
    path.join(projectRoot, 'AGENTS.md'),
  ];

  // Also check .cursor/rules/*.mdc files
  const cursorRulesDir = path.join(projectRoot, '.cursor', 'rules');
  if (fs.existsSync(cursorRulesDir)) {
    const mdcFiles = fs.readdirSync(cursorRulesDir)
      .filter(f => f.endsWith('.mdc'))
      .map(f => path.join(cursorRulesDir, f));
    filesToVerify.push(...mdcFiles);
  }

  if (!options.json) {
    console.log(chalk.blue('\nüîê Verifying compiled outputs...\n'));
  }

  const results: FileVerificationResult[] = [];
  let allValid = true;
  let filesVerified = 0;

  for (const filePath of filesToVerify) {
    const result = await verifyFile(filePath);
    results.push(result);

    if (result.exists && result.hasChecksum) {
      filesVerified++;
      if (!result.valid) {
        allValid = false;
      }
    }
  }

  // Output results
  if (options.json) {
    console.log(JSON.stringify({
      success: allValid,
      filesVerified,
      results: results.map(r => ({
        path: path.relative(projectRoot, r.path),
        exists: r.exists,
        hasChecksum: r.hasChecksum,
        valid: r.valid,
        error: r.error,
      })),
    }, null, 2));
  } else {
    for (const result of results) {
      const relativePath = path.relative(projectRoot, result.path);

      if (!result.exists) {
        if (options.verbose) {
          console.log(chalk.gray(`  ‚è≠Ô∏è  ${relativePath} - not found (skipped)`));
        }
        continue;
      }

      if (!result.hasChecksum) {
        console.log(chalk.yellow(`  ‚ö†Ô∏è  ${relativePath} - no checksum found`));
        continue;
      }

      if (result.valid) {
        console.log(chalk.green(`  ‚úÖ ${relativePath} - valid`));
        if (options.verbose) {
          console.log(chalk.gray(`     Checksum: ${result.embeddedChecksum}`));
        }
      } else {
        console.log(chalk.red(`  ‚ùå ${relativePath} - MODIFIED`));
        if (options.verbose) {
          console.log(chalk.gray(`     Expected: ${result.embeddedChecksum}`));
          console.log(chalk.gray(`     Actual:   ${result.actualChecksum}`));
        }
      }
    }

    console.log('');
    if (filesVerified === 0) {
      console.log(chalk.yellow('‚ö†Ô∏è  No verifiable files found.'));
      console.log(chalk.gray('   Run `ctx build` first to generate compiled outputs.'));
    } else if (allValid) {
      console.log(chalk.green(`‚úÖ All ${filesVerified} file(s) verified successfully`));
    } else {
      console.log(chalk.red(`‚ùå Verification failed - some files have been modified`));
      console.log(chalk.gray('   Run `ctx build` to regenerate from source rules.'));
    }
  }

  return allValid ? 0 : 1;
}
